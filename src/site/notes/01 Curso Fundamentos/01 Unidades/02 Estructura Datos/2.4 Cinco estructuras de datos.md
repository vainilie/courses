---
{"dg-publish":true,"permalink":"/01-curso-fundamentos/01-unidades/02-estructura-datos/2-4-cinco-estructuras-de-datos/","title":"2.4 Cinco estructuras de datos"}
---


# Cinco estructuras de datos

# ‚ö° 5 Estructuras de Datos ARRAYS LIST STACK QUEUE TREE GRAPHS | Curso de Programaci√≥n Desde Cero 2023

![Thumbnail](https://img.youtube.com/vi/D72y6vCEazw/maxresdefault.jpg)

üë§ [EWebik](https://www.youtube.com/channel/UCGLKAojrhnU3Xtoj6azpUsg) üîó [Watch video](https://www.youtube.com/watch?v=D72y6vCEazw)

## Resumen

Este video ofrece una introducci√≥n completa a las estructuras de datos, destacando su importancia fundamental en la programaci√≥n para almacenar, organizar y manipular datos de manera eficiente. Explora diversos tipos de estructuras como arrays, listas enlazadas, pilas, colas, √°rboles y grafos, proporcionando ejemplos en pseudoc√≥digo para ilustrar su funcionamiento. Adem√°s, el video cubre las ventajas de utilizar estructuras de datos, como la mejora de la eficiencia, la reutilizaci√≥n de c√≥digo y la reducci√≥n de la complejidad, e introduce el concepto de complejidad de algoritmos utilizando la notaci√≥n Big O para analizar el rendimiento.

## Puntos clave

- Las estructuras de datos son esenciales para el buen desempe√±o y eficiencia de los programas, permitiendo organizar y manipular datos eficazmente.
- La elecci√≥n adecuada de una estructura de datos optimiza el rendimiento y minimiza el consumo de recursos.
- Existen varios tipos de estructuras de datos (arrays, listas, pilas, colas, √°rboles, grafos), cada una con caracter√≠sticas √∫nicas y utilizada en diferentes situaciones.
- Las estructuras de datos mejoran la eficiencia de operaciones, facilitan la reutilizaci√≥n y organizaci√≥n del c√≥digo, ofrecen flexibilidad y reducen la complejidad.
- La complejidad de las estructuras de datos y algoritmos se mide con la notaci√≥n Big O (O grande), que describe el peor tiempo de ejecuci√≥n en funci√≥n del tama√±o de la entrada.

## Conceptos t√©cnicos

- **[[Estructuras de Datos\|Estructuras de Datos]]**: Formas de organizar y almacenar datos en un programa de computadora para que se puedan acceder y manipular de manera eficiente. Son fundamentales para algoritmos y programas escalables.
- **[[Arrays o Vectores\|Arrays o Vectores]]**: Colecciones de elementos del mismo tipo de datos, organizados en una secuencia contigua de memoria y accesibles a trav√©s de √≠ndices que generalmente comienzan en 0.
- **[[Listas Enlazadas\|Listas Enlazadas]]**: Colecciones de elementos (nodos) donde cada nodo contiene un valor y un puntero que enlaza al siguiente nodo, permitiendo una secuencia din√°mica.
- **[[Pilas (Stacks)\|Pilas (Stacks)]]**: Estructura de datos lineal que sigue el principio LIFO (Last In, First Out), donde los elementos se insertan (apilar/push) y eliminan (desapilar/pop) por el mismo extremo, conocido como la ‚Äúcima‚Äù.
- **[[Colas (Queues)\|Colas (Queues)]]**: Estructura de datos lineal que sigue el principio FIFO (First In, First Out), donde los elementos se insertan (encolar/enqueue) por un extremo y se eliminan (desencolar/dequeue) por el otro.
- **[[√Årboles (Trees)\|√Årboles (Trees)]]**: Estructura de datos jer√°rquica con un elemento ra√≠z en la parte superior y nodos que se organizan en niveles, extendi√©ndose hacia abajo mediante ramas (nodos hijos).
- **[[Grafos (Graphs)\|Grafos (Graphs)]]**: Estructura de datos compuesta por nodos (v√©rtices) y aristas (conexiones) que representan relaciones entre ellos, donde cada nodo puede estar conectado a otros.
- **[[Notaci√≥n Big O (O Grande)\|Notaci√≥n Big O (O Grande)]]**: Herramienta matem√°tica utilizada para describir el peor tiempo de ejecuci√≥n o el uso de memoria que un algoritmo tomar√° en funci√≥n del tama√±o de su entrada (n), indicando la tasa de crecimiento asint√≥tico.

## C√≥digo o ejemplos mencionados

- **Arrays o Vectores:**
	- Creaci√≥n de un arreglo en pseudoc√≥digo: `arregloNumeros = [5, 10, 15, 20, 25]`.
	- Acceso a elementos: El elemento en el √≠ndice 2 es el tercer elemento (15).
	- Modificaci√≥n de elementos: `arregloNumeros[3] = 30` cambia el cuarto elemento a 30.
- **Listas Enlazadas:**
	- Creaci√≥n de nodos con `valor` y `siguiente` (puntero).
	- Ejemplo de c√≥mo los nodos se enlazan (`nodo3` enlaza a `nodo2`, `nodo2` a `nodo1`).
	- Asignaci√≥n del primer nodo a una variable `inicio`.
	- Un bucle `while` para recorrer e imprimir los valores de la lista hasta que el `nodoActual.siguiente` sea `null`.
- **Pilas:**
	- Creaci√≥n de una pila vac√≠a.
	- Operaci√≥n `apilar` (push): Se agregan elementos (5, 10, 15) uno encima del otro, siendo 15 la cima.
	- Operaci√≥n `desapilar` (pop): Se extraen elementos desde la cima (15, luego 10), mostrando c√≥mo se eliminan de la pila.
- **Colas:**
	- Creaci√≥n de una cola vac√≠a.
	- Operaci√≥n `encolar` (enqueue): Se agregan elementos (5, 10, 15) a la cola.
	- Operaci√≥n `desencolar` (dequeue): Se extraen elementos en orden de entrada (5, luego 10), demostrando el principio FIFO.
- **√Årboles:**
	- Creaci√≥n de una `raiz` con un valor y brazos `izquierdo` y `derecho` (posibles nodos hijos).
	- Asignaci√≥n de nodos hijos a la izquierda y derecha de la ra√≠z, mostrando la construcci√≥n de la estructura jer√°rquica.
- **Grafos:**
	- Representaci√≥n de un grafo con 4 v√©rtices mediante una matriz de adyacencia conceptual (ceros y unos), donde los unos indican la existencia de una arista (conexi√≥n directa) entre dos v√©rtices y los ceros su ausencia. Se analiza la conectividad entre diferentes v√©rtices.
- **Big O (`O(n)`):**
	- Algoritmo para encontrar el valor m√°ximo en un arreglo. Se explica que el peor caso implica recorrer todo el arreglo, lo que resulta en una complejidad lineal `O(n)`.

## Recursos mencionados

- **webbick.com**: La p√°gina web del creador del contenido donde se sube la parte escrita de las clases del curso.

## Conclusi√≥n

Las estructuras de datos son un pilar fundamental en la programaci√≥n. Comprender sus diferentes tipos, sus ventajas y desventajas, y c√≥mo analizar su complejidad con herramientas como la notaci√≥n Big O, es crucial para cualquier programador. Elegir la estructura correcta para cada situaci√≥n permite construir programas m√°s eficientes, escalables y f√°ciles de mantener.
